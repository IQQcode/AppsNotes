## 1. Service简介

### 什么是Service

Service表示“服务”，是Android系统的核心组件之一,**用来在后台完成时间跨度较大的工作，且没有任何界面**。**即使应用退出，覅我也不会停止**

> "后台"：没有和界面关联

- Service的本质是一个继承了`andriod.app.Service`的JAVA类；
- 每一个Service都应该在AndroidManifest.xml中进行注册
- Service由Android系统进行维护

Service没有匹配的用户界面，通常用于在后台执行**耗时操作**

- 不允许在主线程中执行耗时操作
- Service是运行在主线程中的

尽管Service被定位为“用于处理耗时操作”，**但是各种耗时操作需要在Service中另外开辟线程来完成**。

组件可以绑定到Service，**实现进程间通信**（IPC:Inter Process Communication)。

> 注意：Android服务不是线程或单独的进程

### Service的分类

**1. Local Service [本地服务]**

Service对象与Service的启动者在**同个进程**中运行，两者的通信是进程内的通信

**2. Remote Service [远程服务]**

Service对象与Service的启动者**不在同一个进程内**，Android通过AID来实现进程间通信

<br>

### 进程的优先级

进程的优先级分类如下(从高到低)：**[包含Service的进程为前三个]**

**1. 前台进程 Foreground Process**

- 正在与用户交互的Activity
- 存在Service，且该Service编订在用户交互的Activity之上
- 存在运行前台的Service，该Service的`startForeground()`被调用

**2. 可见进程 Visible Process**

并无前台组件，但包含用户可见的组件

- 处于暂停态的Activity
- 存于绑定在可见Activity之上得Service

**3. 服务进程 Service Process**

使用`startService()`方式启动的Service，但该Service并未上升到前台、可见的级别

**4. 后台进程 Background Process**

大多表现为`onStop()`之后的Activity

**5. 空进程 Empty Process**

不包含任何活动的组件的进程，为了便于缓存组件，以提高下次启动的效率，系统可能仍然展示保留他们

<br>

## 2. 启动Service

**Android Service 的两种启动方法**

服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都 可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服 务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的 特点。

如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。

如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的 onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方 法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致 多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务解除绑定，可以调用 unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()–>onDestroy()方法。

### 2.1 Context激活Service

**[方式一] 使用Context激活Service组件**

显示或隐式启动Service

- 显示或者隐式Intent都可以激活Service
- 要实现进程间通信，则应该为Service组件配置隐式Intent

```java
context.startService(Intent intent);
context.stopService(Intent intent);
```

**启动Service的开发流程如下：**

1. 创建

2. Java类，继承android.app.Service

    > Service中定义了抽象方法onBind()，该方法被重写，但不一定需要被

3. 在AndroidManifest.xml中的`<application>`下添加`<service>`子节点，**<font color = red>配置创建的Service</font>**

4. 在Activity中调用`startService(Intent intent)`方法启动Service

### 2.2 绑定模式激活Service

使用绑定的Service可以实现组件与Service的通信。

组件与被绑定的Service可以不归属于同一个应用程序，因此通过绑定Service可以实现进程间通信。

![image-20210409113452294](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-befo/20210409113700.png)



调用`bindService(Intent service,ServiceConnection conn,int flags)`方法即可实现当前组件与Service的绑定。

【参数说明】：

- Intent service:配置被激活的Sevice组件，该Intent可以是显式的，也可以是隐式的；
- ServiceConnection conn:当前组件与被激活的Service的连接对象，当成功的以绑定模式激活Service后，该Service的onBind()方法的返回值(非null)对象被会回传到当前组件，即当前组件与被激活的Service存在相同的IBinder对象；
- int flags:标志

**关于Service的onBind()方法**

- 在绑定Service时，定义的Service类中，onBind()方法应该返回一个非null的值。
- onBind()方法的返回值类型是IBinder类型，IBinder是接口，开发人员可以自定义类实现该接口。

> Google官方并不推荐开发人员直接定义类实现IBinder接口，而是通过继承Binder类即可，Binder类是IBinder接口的实现类。

- 如果onBind()方法的返回值是null,则该绑定过程是失败的，尽管Service也会执行onCreate()方法开始工作，但其它组件无法与Service通信。

<br>

#### 实现绑定Service

实现Activity绑定Service的开发步骤如下：

创建JAVA类继承android.app.Service类，并在AndroidManifest.xml中注册该Service;

在自定义的Service类中创建IBinder的对象，作为onBind()方法的返回值

在Activity中创建ServiceConnection的对象；

在Activity中调用bindService()方法实现与Service的绑定；

重写Activity的onDestroy()方法，调用unbindService()方法取消与Service的绑定，以避免当Activity被销毁时绑定仍然存在而导致的异常。

```java
top.iqqcode.bindservice E/TAG: ServiceTest onBind: Binder 124931812
top.iqqcode.bindservice E/TAG: MainActivity onServiceConnected: ==> IBinder Service 124931812
```



#### 取消绑定Service

当与Service绑定的组件被销毁时，应该及时取消与Service的绑定，否则会导致异常。

在组件中，调用unbindService(ServiceConnection conn)方法则可以取消与Service的绑定。

**此外，还需要在onDestroy中也要解除绑定**







<br>

## 3. 停止Service

**[方式一]** Service中调用`stopSelf()`方法可以停止自身

**[方式二]** 通过Context的`stopService(Intent intent)`方法可停止Service,并销毁该Service组件

## 4. Service生命周期

![service_lifecycle](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-befo/20210408221425.png)



**Service的生命周期分为 start Service(启动模式) 和 bind Service(绑定模式) 两种**

如果Activity反复调用`startService()`方法，在Service中只会反复调用`onStartCo mmand()`方法。

There can be two forms of a service.The lifecycle of service can follow two different paths: started or bound.

1. Started
2. Bound

**1) Started Service**

当组件（如活动）调用startService()方法时，将启动服务，现在该服务将无限期在后台运行。 它由`stopService()`方法停止。 该服务可以通过调用`stopSelf()`方法来停止自身。

**2) Bound Service**

当另一个组件（例如客户端）调用`bindService()`方法时，将绑定服务。 客户端可以通过调用`unbindService()`方法来取消绑定服务。**在所有客户端解除绑定服务之前，无法停止该服务。**

### 4.1 启动模式生命周期

使用**startService()方式激活的Service组件默认是是粘性的**

![image-20210409095017004](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-befo/20210409095018.png)

- **【第一次调用】** 构造方法 => onCreat() => onStartCommand()

- **【后面再调用】** onStartCommand()

- 点击销毁：onDestroy

```java
top.iqqcode.servicelifecycle E/TAG:  ==> onCreate
top.iqqcode.servicelifecycle E/TAG:  ===> onStartCommand
top.iqqcode.servicelifecycle E/TAG:  ===> onDestroy 
```

销毁之后再 **多次点击创建**

```java
top.iqqcode.servicelifecycle E/TAG:  ==> onCreate
top.iqqcode.servicelifecycle E/TAG:  ===> onStartCommand
top.iqqcode.servicelifecycle E/TAG:  ===> onStartCommand
top.iqqcode.servicelifecycle E/TAG:  ===> onStartCommand
top.iqqcode.servicelifecycle E/TAG:  ===> onStartCommand
top.iqqcode.servicelifecycle E/TAG:  ===> onStartCommand
top.iqqcode.servicelifecycle E/TAG:  ===> onStartCommand
```

### 4.2 绑定模式生命周期

**【绑定】** 构造方法 => onCreate() => onBind() => onServiceConnected()

**【解除绑定】** unbindService() => onUnBind() => onDestroy()

![RfqYC](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-befo/20210409133821.png)

使用**bindService()方式激活的Service组件 不是粘性的**

**【绑定Sevice的回调过程】**

![image-20210409134246695](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-befo/20210409134246.png)

**【取消绑定Sevice的回调过程】**

> 当绑定了Service之后，Activity被销毁之前应该取消与Service的绑定，否则将抛出异常。

![image-20210409134352449](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-befo/20210409134352.png)

**注意：**

以绑定模式激活的Service组件并不是粘性的，且与Service绑定的组件在退出之前必须取消绑定，即无法保证Service组件依然存在，所以，为了保证其它组件可以销毁，但Service依然存在，可以：

1. 先调用startService()激活Service组件；
2. 再调用bindService()实现绑定。



<br>

## 5. Service的粘性

Service的粘性表现为：**其所在进程被意外中止后，该Service是否可以自动重新被启动。**

默认情况下，使用**startService()方式激活的Service组件默认是是粘性的**，即使其所在进程被**意外中止(不会调用onDestroy方法)**了，稍后该Service依然会被自动创建出来。

### 设置Service的粘性

在Service生命周期中`onStartCommand()`方法的返回值决定了Service的粘性。

该方法的返回值可以被设置为：

- `START_STICKY`: 粘性的，被意外中止后自动重启，但丢失原来用于激活它的Intent;
- `START_NOT_STICKY` : 非粘性的，被意外中止后不会自动重启；
- `START_REDELIVER_INTENT` : 粘性的且重新发送Intent,即被意外中止后自动重启，且该Service组件将得到原来用于激活它的Intent对象；
- `START_STICKY_COMPATIBILITY` : START_STICKY的兼容版本，并不担保`onStartCommand()`会被重新调用。

<br>

